import org.apache.tools.ant.filters.ReplaceTokens
import java.util.*

plugins {
    kotlin("jvm") version "2.2.20-RC"
    id("com.gradleup.shadow") version "8.3.0"
    id("xyz.jpenilla.run-paper") version "2.3.1"
    id("org.jetbrains.kotlin.plugin.serialization") version "1.6.21"
}

val versionFile = File(rootProject.projectDir, "version.txt")
val versionString = if (versionFile.exists()) {
    versionFile.readText().trim()
} else {
    // A fallback in case the file doesn't exist
    "0.0.0-SNAPSHOT"
}

group = "bk.minecraftplugin"
version = versionString

repositories {
    mavenCentral()
    maven("https://repo.papermc.io/repository/maven-public/") {
        name = "papermc-repo"
    }
}

dependencies {
    compileOnly("io.papermc.paper:paper-api:1.21.8-R0.1-SNAPSHOT")
    implementation("org.jetbrains.kotlin:kotlin-stdlib-jdk8")
    implementation("io.ktor:ktor-client-core:3.2.3")
    implementation("io.ktor:ktor-client-cio:3.2.3")
    implementation("io.ktor:ktor-client-content-negotiation:3.2.3")
    implementation("io.ktor:ktor-serialization-kotlinx-json:3.2.3")

}

tasks.register("make") {
    // The dependsOn property is configured here.
    dependsOn("clean", "assemble", "shadowJar")
    tasks.findByName("assemble")?.mustRunAfter("clean")
    tasks.findByName("shadowJar")?.mustRunAfter("assemble")

    // We add a description to make it clear what the task does.
    description = "Executes clean, assemble, and shadowJar in sequence."
    doLast {
        println(" ==> Built version ${versionString} <==")
    }
}


sourceSets {
    main {
        kotlin.srcDirs("src/main/kotlin", "build/generated/kotlin/main")
//        resources.srcDirs("src/main/resources")
    }
}
tasks.named("compileKotlin") {
    dependsOn("generateBuildConfig")
}

tasks.shadowJar {
    archiveClassifier = ""
}

tasks {
    runServer {
        // Configure the Minecraft version for our task.
        // This is the only required configuration besides applying the plugin.
        // Your plugin's jar (or shadowJar if present) will be used automatically.
        minecraftVersion("1.21")
    }
}

val properties = Properties()
val localPropertiesFile = file("local.properties")
if (localPropertiesFile.exists()) {
    localPropertiesFile.inputStream().use { properties.load(it) }
}
//project.ext.set("webhookUrl", properties.getProperty("webhook_url"))
val webhookUrl = properties.getProperty("webhook_url") ?: ""
val configUrl = properties.getProperty("config_url") ?: ""
val minecraftUserToDiscordIdMapStr = properties.getProperty("minecraft_name_to_discord_id_map") ?: ""

val minecraftUserToDiscordIdMap = minecraftUserToDiscordIdMapStr.split(',').associate {
    val (key, value) = it.split(':')
    key.trim() to value.trim()
}
val generatedSrcDir = layout.buildDirectory.dir("generated/kotlin/main").get().asFile
val generatedPackage = "bk.minecraftplugin.playerWatcherPaperMCPlugin"
val generatedFileName = "BuildConfig.kt"
val generatedFile = File(generatedSrcDir, generatedPackage.replace(".", "/") + "/$generatedFileName")

fun Map<String, String>.generateMapAsString(): String {
    val entries = this.entries.joinToString(",\n") { "\"${it.key}\" to \"${it.value}\"" }
    return """
        mapOf(
           $entries 
        )
    """.trimIndent()
}

// Create a custom task to generate the file
tasks.register("generateBuildConfig") {
    // This task's output is the generated file
    outputs.file(generatedFile)

    doLast {
        // Ensure the directory exists
        generatedSrcDir.mkdirs()

        // Write the Kotlin code to the file
        generatedFile.writeText(
            """
            // This file is auto-generated by Gradle. DO NOT EDIT.
            package $generatedPackage
            
            object BuildConfig {
                const val WEBHOOK_URL = "$webhookUrl"
                const val CONFIG_URL = "$configUrl"
                val MINECRAFT_USER_TO_DISCORD_ID_MAP = ${minecraftUserToDiscordIdMap.generateMapAsString()}
            }
            """.trimIndent()
        )
    }
}


val targetJavaVersion = 21
kotlin {
    jvmToolchain(targetJavaVersion)
}

tasks.build {
    dependsOn("shadowJar")
}


tasks.processResources {

    // Specify the file to process (your plugin.yml)
    // You can use a more specific filter if needed, like:
    include("plugin.yml")

    // Apply a filter that replaces a token with the version string
    filter<ReplaceTokens>("tokens" to mapOf("version" to versionString))
    val props = mapOf("version" to version)
    inputs.properties(props)
    filteringCharset = "UTF-8"
    filesMatching("plugin.yml") {
        expand(props)
    }

}
